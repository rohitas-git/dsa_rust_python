## What Problems Does Programming Solve? (https://jarednielsen.com/programming-problem-solving/)

We can distill programming-related problems into two categories:
- Algorithms
- Automation

With algorithms, our goal is to find the most efficient way to perform an operation, such as sorting or searching. 

With automation, our goal is to find a way to repeatedly perform an operation, such as processing a dataset or dynamically rendering HTML.

In many regards, algorithms and automation are one and the same problem.

## What is Programming?

Programming is the act and art of writing instructions to be executed by a machine. These instructions must follow a predetermined, formalized, set of rules. These rules determine what we can write and how we can use those whats. 

A programming language is, fundamentally, a combination of logic and syntax, or a set of instructions for writing instructions. So meta!

One of the biggest challenges in learning to program is making the transition from natural language to formal language, or, learning to think like a computer. <br>
Programming is a metacognitive activity. To be successful, we need to improve our ability to think about thinking.

## What is Problem Solving?

According to Wikipedia, problem solving
> …consists of using generic or ad hoc methods in an orderly manner to find solutions to problems.


In the classic How To Solve It, George Polya outlines a methodology for problem-solving in the context of mathematics. We can easily apply it to programming. Polya’s heuristics can be distilled into four ordinate categories, each with specific questions to ask:

1. <b>Understand the Problem</b>: What is the problem? What is the goal? Describe the issue or bug. What is the console or terminal telling you? If there is no feedback, why might that be so and what can you do about it?

2. <b>Devise a Plan</b>: Have you seen this problem, or something like it, before? If you haven’t seen this problem before, can you restate it in terms you are familiar with? Can you break the problem down into smaller problems that are familiar and accessible?

3. <b>Execute the Plan </b>

4. <b>Examine the Solution</b>: What is the solution? Explain it. Can it be modified? If so, what could be improved, if anything? Could we use this solution for other problems?

## Programming is Problem Solving

    One does not expect anything to work at the first try. One does not judge by standards like ‘right—you get a good grade’ and ‘wrong—you get a bad grade’. Rather one asks the question: ‘How can I fix it?’ and to fix it one has first to understand what happened in its own terms.

    -Seymour Papert

Papert sees the computer as helping learners confront their intuitions in two ways:

- The computer allows, or obliges, the [learner] to externalize intuitive expectations. When the intuition is translated into a program it becomes more obtrusive and more accessible to reflection.

- Computational ideas can be taken up as materials for the work of remodeling intuitive knowledge.

The key to long-term success in programming is in this two-fold process of reflection and remodeling, or, learning how to think about thinking. Ultimately, what each of us needs is a better understanding of ourselves. Why did you think this approach would or would not work? Why do you think it does or doesn’t? What does this situation reveal to you about your assumptions and intuitions? Your biases? Bugs are “an intrinsic part of the learning process”, not something to be avoided. It is through debugging that we learn the most about ourselves.

### Reflect and Remodel

>> The key technique is asking yourself why you made a particular mistake, rather than just fixing the mistake and moving on.

-V. Spraul